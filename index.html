<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Superhero vs Monsters</title>
  <style>
    html, body { margin: 0; padding: 0; background: #2d2f49; }
    canvas { display: block; margin: 0 auto; background: #6ec2ff; image-rendering: pixelated; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="900" height="420"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // assets
    const heroIdle = new Image();
    const heroSlash = new Image();
    const monsterSprite = new Image();
    const bgForest = new Image();
    heroIdle.src = 'hero_idle.png';
    heroSlash.src = 'hero_slash.png';
    monsterSprite.src = 'monster_sprite.png';
    bgForest.src = 'forest_bg.png';

    const groundY = 360;
    let hero, monsters, score, over, spawnTimer, speed, bgX1, bgX2, bgSpeed, boostTimer, boostActive;

    function resetGame() {
      hero = {
        x: 80,
        y: groundY - 64,
        w: 64,
        h: 64,
        vy: 0,
        gravity: 0.7,
        jump: -13,
        onGround: true,
        slashing: false,
        slashTimer: 0
      };
      monsters = [];
      score = 0;
      over = false;
      spawnTimer = 0;
      speed = 5;
      bgX1 = 0;
      bgX2 = canvas.width;
      bgSpeed = 2;
      boostTimer = 0;
      boostActive = false;
    }

    // parallax background
    function drawBackground() {
      ctx.drawImage(bgForest, bgX1, 0, canvas.width, canvas.height);
      ctx.drawImage(bgForest, bgX2, 0, canvas.width, canvas.height);
      bgX1 -= bgSpeed;
      bgX2 -= bgSpeed;
      if (bgX1 <= -canvas.width) bgX1 = bgX2 + canvas.width;
      if (bgX2 <= -canvas.width) bgX2 = bgX1 + canvas.width;
    }

    function drawGround() {
      ctx.fillStyle = '#4f944f';
      ctx.fillRect(0, groundY, canvas.width, 8);
      ctx.fillStyle = '#3a6b3a';
      for (let i = 0; i < canvas.width; i += 20) {
        ctx.fillRect(i, groundY + 8, 10, 6);
      }
    }

    function drawHero() {
      const img = hero.slashing ? heroSlash : heroIdle;
      ctx.drawImage(img, hero.x, hero.y, hero.w, hero.h);
      if (hero.slashing) {
        hero.slashTimer--;
        if (hero.slashTimer <= 0) hero.slashing = false;
      }
    }

    function drawMonster(m) {
      ctx.drawImage(monsterSprite, m.x, m.y, m.w, m.h);
    }

    function updateHero() {
      hero.y += hero.vy;
      hero.vy += hero.gravity;
      if (hero.y + hero.h >= groundY) {
        hero.y = groundY - hero.h;
        hero.vy = 0;
        hero.onGround = true;
      } else {
        hero.onGround = false;
      }
    }

    // type 0 walker, type 1 jumper
    function spawnMonster() {
      const type = Math.random() < 0.6 ? 0 : 1;
      const m = { x: canvas.width, y: groundY - 64, w: 64, h: 64, vx: speed, type: type, vy: 0 };
      monsters.push(m);
    }

    function updateMonsters() {
      for (let i = monsters.length - 1; i >= 0; i--) {
        const m = monsters[i];
        m.x -= m.vx;
        if (m.type === 1) {
          m.y += m.vy;
          m.vy += 0.8;
          if (m.y + m.h >= groundY) {
            m.y = groundY - m.h;
            m.vy = -12 - Math.random() * 4;
          }
        }
        if (m.x + m.w < 0) monsters.splice(i, 1);
      }
    }

    function collide(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function handleCollisions() {
      for (let i = monsters.length - 1; i >= 0; i--) {
        const m = monsters[i];
        if (collide(hero, m)) {
          if (hero.slashing) {
            monsters.splice(i, 1);
            score += 5;
          } else {
            over = true;
          }
        }
      }
    }

    function drawUI() {
      ctx.fillStyle = '#000';
      ctx.font = '20px monospace';
      ctx.fillText('Score ' + score, 12, 26);
      if (boostActive) {
        ctx.font = '18px monospace';
        ctx.fillText('Speed boost', canvas.width - 180, 26);
      }
    }

    function applyDifficulty() {
      if (score > 0 && score % 20 === 0 && boostTimer === 0) {
        speed += 0.5;
        bgSpeed = 2 + (speed - 5) * 0.3;
        boostActive = true;
        boostTimer = 60;
      }
      if (boostTimer > 0) {
        boostTimer--;
        if (boostTimer === 0) boostActive = false;
      }
    }

    document.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        if (hero.onGround && !over) {
          hero.vy = hero.jump;
          e.preventDefault();
        }
      } else if (e.code === 'KeyS') {
        if (!over) {
          hero.slashing = true;
          hero.slashTimer = 14;
          e.preventDefault();
        }
      } else if (e.code === 'Enter') {
        resetGame();
        e.preventDefault();
      }
    }, false);

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      drawGround();

      if (!over) {
        spawnTimer++;
        if (spawnTimer > 70) {
          spawnMonster();
          spawnTimer = 0;
          score++;
        }

        applyDifficulty();
        updateHero();
        updateMonsters();
        handleCollisions();

        drawHero();
        monsters.forEach(drawMonster);
        drawUI();

        requestAnimationFrame(gameLoop);
      } else {
        ctx.fillStyle = '#000';
        ctx.font = '40px monospace';
        ctx.fillText('Game Over', canvas.width/2 - 120, canvas.height/2 - 10);
        ctx.font = '18px monospace';
        ctx.fillText('Press Enter to restart', canvas.width/2 - 120, canvas.height/2 + 30);
        drawHero();
        monsters.forEach(drawMonster);
        drawUI();
        requestAnimationFrame(gameLoop);
      }
    }

    let loaded = 0;
    function startIfReady() {
      loaded++;
      if (loaded === 4) {
        resetGame();
        requestAnimationFrame(gameLoop);
      }
    }
    heroIdle.onload = startIfReady;
    heroSlash.onload = startIfReady;
    monsterSprite.onload = startIfReady;
    bgForest.onload = startIfReady;
  </script>
</body>
</html>